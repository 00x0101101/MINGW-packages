diff -Naur Python-3.7.0-orig/Include/internal/pystate.h Python-3.7.0/Include/internal/pystate.h
--- Python-3.7.0-orig/Include/internal/pystate.h	2018-06-30 11:16:58.540296800 +0300
+++ Python-3.7.0/Include/internal/pystate.h	2018-06-30 11:17:01.363901700 +0300
@@ -43,7 +43,8 @@
     wchar_t *prefix;
 #ifdef MS_WINDOWS
     wchar_t *dll_path;
-#else
+#endif
+#ifndef _MSC_VER
     wchar_t *exec_prefix;
 #endif
     /* Set by Py_SetPath(), or computed by _PyPathConfig_Init() */
diff -Naur Python-3.7.0-orig/Modules/getpath.c Python-3.7.0/Modules/getpath.c
--- Python-3.7.0-orig/Modules/getpath.c	2018-06-30 11:17:01.020701100 +0300
+++ Python-3.7.0/Modules/getpath.c	2018-06-30 11:17:01.363901700 +0300
@@ -11,6 +11,11 @@
 #  include <mach-o/dyld.h>
 #endif
 
+#ifdef MS_WINDOWS
+#include <windows.h>
+#include <shlwapi.h>
+#endif
+
 /* Search in some common locations for the associated Python libraries.
  *
  * Two directories must be found, the platform independent directory
@@ -523,6 +527,97 @@
 }
 
 
+#ifdef MS_WINDOWS
+static int _PathCchCanonicalizeEx_Initialized = 0;
+typedef HRESULT(__stdcall *PPathCchCanonicalizeEx) (PWSTR pszPathOut, size_t cchPathOut,
+    PCWSTR pszPathIn, unsigned long dwFlags);
+static PPathCchCanonicalizeEx _PathCchCanonicalizeEx;
+
+static _PyInitError canonicalize(wchar_t *buffer, const wchar_t *path)
+{
+    if (buffer == NULL) {
+        return _Py_INIT_NO_MEMORY();
+    }
+
+    if (_PathCchCanonicalizeEx_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryW(L"api-ms-win-core-path-l1-1-0.dll");
+        if (pathapi) {
+            _PathCchCanonicalizeEx = (PPathCchCanonicalizeEx)GetProcAddress(pathapi, "PathCchCanonicalizeEx");
+        }
+        else {
+            _PathCchCanonicalizeEx = NULL;
+        }
+        _PathCchCanonicalizeEx_Initialized = 1;
+    }
+
+    if (_PathCchCanonicalizeEx) {
+        if (FAILED(_PathCchCanonicalizeEx(buffer, MAXPATHLEN + 1, path, 0))) {
+            return _Py_INIT_ERR("buffer overflow in getpath.c's canonicalize()");
+        }
+    }
+    else {
+        if (!PathCanonicalizeW(buffer, path)) {
+            return _Py_INIT_ERR("buffer overflow in getpath.c's canonicalize()");
+        }
+    }
+    return _Py_INIT_OK();
+}
+
+
+static int
+GetWindowsModulePaths(_PyPathConfig *config)
+{
+    _PyInitError err;
+    int result = 0;
+    wchar_t program_full_path[MAXPATHLEN+1];
+    memset(program_full_path, 0, sizeof(program_full_path));
+
+    if (!GetModuleFileNameW(NULL, program_full_path, MAXPATHLEN)) {
+        result = 1;
+        /* GetModuleFileName should never fail when passed NULL */
+        // return _Py_INIT_ERR("Cannot determine program path");
+    }
+    Py_NormalizeSepsW(program_full_path);
+
+    config->program_full_path = PyMem_RawMalloc(
+        sizeof(wchar_t) * (MAXPATHLEN + 1));
+
+    err = canonicalize(config->program_full_path,
+                        program_full_path);
+    if (_Py_INIT_FAILED(err)) {
+        result = 0;
+    }
+    return result;
+}
+
+
+static _PyInitError
+get_dll_path(PyCalculatePath *calculate, _PyPathConfig *config)
+{
+    wchar_t dll_path[MAXPATHLEN+1];
+    memset(dll_path, 0, sizeof(dll_path));
+
+#ifdef Py_ENABLE_SHARED
+    extern HANDLE PyWin_DLLhModule;
+    if (PyWin_DLLhModule) {
+        if (!GetModuleFileNameW(PyWin_DLLhModule, dll_path, MAXPATHLEN)) {
+            dll_path[0] = 0;
+        }
+        Py_NormalizeSepsW(dll_path);
+    }
+#else
+    dll_path[0] = 0;
+#endif
+
+    config->dll_path = _PyMem_RawWcsdup(dll_path);
+    if (config->dll_path == NULL) {
+        return _Py_INIT_NO_MEMORY();
+    }
+    return _Py_INIT_OK();
+}
+#endif /* MS_WINDOWS */
+
+
 static _PyInitError
 calculate_program_full_path(const _PyCoreConfig *core_config,
                             PyCalculatePath *calculate, _PyPathConfig *config)
@@ -570,14 +665,19 @@
     char execpath[MAXPATHLEN+1];
 #endif
 
+#ifdef MS_WINDOWS
+    if(GetWindowsModulePaths(config)) {
+    }
+#else
     /* If there is no slash in the argv0 path, then we have to
      * assume python is on the user's $PATH, since there's no
      * other way to find a directory to start the search from.  If
      * $PATH isn't exported, you lose.
      */
     if (wcschr(core_config->program_name, SEP)) {
         wcsncpy(program_full_path, core_config->program_name, MAXPATHLEN);
     }
+#endif /* MS_WINDOWS */
 #ifdef __APPLE__
      /* On Mac OS X, if a script uses an interpreter of the form
       * "#!/opt/python2.3/bin/python", the kernel only passes "python"
@@ -703,9 +703,11 @@
     else {
         program_full_path[0] = '\0';
     }
+#ifndef MS_WINDOWS
     if (program_full_path[0] != SEP && program_full_path[0] != '\0') {
         absolutize(program_full_path);
     }
+#endif
 
     config->program_full_path = _PyMem_RawWcsdup(program_full_path);
     if (config->program_full_path == NULL) {
@@ -892,6 +991,13 @@
 {
     _PyInitError err;
 
+#ifdef MS_WINDOWS
+    err = get_dll_path(calculate, config);
+    if (_Py_INIT_FAILED(err)) {
+        return err;
+    }
+#endif
+
     err = calculate_program_full_path(core_config, calculate, config);
     if (_Py_INIT_FAILED(err)) {
         return err;
@@ -968,6 +1074,48 @@
     return err;
 }
 
+
+#ifdef MS_WINDOWS
+/* Load python3.dll before loading any extension module that might refer
+   to it. That way, we can be sure that always the python3.dll corresponding
+   to this python DLL is loaded, not a python3.dll that might be on the path
+   by chance.
+   Return whether the DLL was found.
+*/
+static int python3_checked = 0;
+static HANDLE hPython3;
+int
+_Py_CheckPython3(void)
+{
+    wchar_t py3path[MAXPATHLEN+1];
+    wchar_t *s;
+    if (python3_checked) {
+        return hPython3 != NULL;
+    }
+    python3_checked = 1;
+
+    /* If there is a python3.dll next to the python3y.dll,
+       assume this is a build tree; use that DLL */
+    wcscpy(py3path, dllpath);
+    s = wcsrchr(py3path, Py_GetSepW(py3path));
+    if (!s) {
+        s = py3path;
+    } else {
+        s += 1;
+    }
+    wcscpy(s, L"python3.dll");
+    hPython3 = LoadLibraryExW(py3path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
+    if (hPython3 != NULL)
+        return 1;
+
+    /* Check sys.prefix\DLLs\python3.dll */
+    wcscpy(py3path, Py_GetPrefix());
+    wcscat(py3path, L"\\DLLs\\python3.dll");
+    hPython3 = LoadLibraryExW(py3path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
+    return hPython3 != NULL;
+}
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff -Naur Python-3.7.0-orig/Modules/posixmodule.c Python-3.7.0/Modules/posixmodule.c
--- Python-3.7.0-orig/Modules/posixmodule.c	2018-06-30 11:17:01.036301200 +0300
+++ Python-3.7.0/Modules/posixmodule.c	2018-06-30 11:17:01.379501800 +0300
@@ -3524,7 +3524,7 @@
         Py_END_ALLOW_THREADS
         /* FindNextFile sets error to ERROR_NO_MORE_FILES if
            it got to the end of the directory. */
-        if (!result && GetLastError() != ERROR_NO_MORE_FILES) {
+        if (!result && GetLastError() != 0 && GetLastError() != ERROR_NO_MORE_FILES) {
             Py_DECREF(list);
             list = path_error(path);
             goto exit;
--- Python-3.7.0/Python/pathconfig.c.orig	2018-06-27 06:07:35.000000000 +0300
+++ Python-3.7.0/Python/pathconfig.c	2018-07-02 08:14:54.324696000 +0300
@@ -32,7 +140,8 @@
     CLEAR(config->program_full_path);
 #ifdef MS_WINDOWS
     CLEAR(config->dll_path);
-#else
+#endif
+#ifndef _MSC_VER
     CLEAR(config->exec_prefix);
 #endif
     CLEAR(config->module_search_path);
@@ -145,7 +254,8 @@
     new_config.prefix = _PyMem_RawWcsdup(L"");
 #ifdef MS_WINDOWS
     new_config.dll_path = _PyMem_RawWcsdup(L"");
-#else
+#endif
+#ifndef _MSC_VER
     new_config.exec_prefix = _PyMem_RawWcsdup(L"");
 #endif
     new_config.module_search_path = _PyMem_RawWcsdup(path);
@@ -224,7 +335,7 @@
 wchar_t *
 Py_GetExecPrefix(void)
 {
-#ifdef MS_WINDOWS
+#ifdef _MSC_VER
     return Py_GetPrefix();
 #else
     pathconfig_global_init();
